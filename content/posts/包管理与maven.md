---
title: "包管理与maven"
date: 2020-05-18T15:59:27+08:00
draft: false
---

# java的包管理与maven初步

### jvm的工作流程
1. 执行一个类的字节码
2. 执行过程中碰到新的类，加载它
3. 接着执行
   
### 在哪里可以找到类-----类路径(Classpath)  -classpath/-cp
1. 类在加载过程中会去classpath中逐个寻找对应的类，碰到了jar包就会去解压，碰到文件夹就会进文件夹找，知道找不到为止就会报错
 
2. 类的全限定类名（目录层级）确定了唯一的类

3. jar包就是把许多类放在一起打的压缩包
 
4. 传递性依赖
   * 你依赖的类还依赖了别的类
   * 你要运行一个程序，不能只放一个jar包，需要把所有要用的类放到classpath
  
5. Classpath hell（依赖地狱）
   * 全限定类名是类的唯一标识
   * 当多个同名类同时出现在Classpath中，就是噩梦的开始
        * 要引用哪个类呢？----谁在前面就用谁
   * 但是同名类里的代码不一样，可能会产生错误

### 包管理
1. 你要使用一些第三方类，就要告诉jvm去哪里找
2. 包管理的本质就是告诉jvm如何找到所需的第三方类库
3. 解决其中的冲突问题


# Maven---划时代的包管理
1. 约定优于配置
 
2. Maven远远不止是包管理工具

3. Maven的中央仓库
    * 按照一定的约定存储包
  
4. Maven 的本地仓库
   * 默认位于~~/.2
   * 下载的第三方包在这里进行缓存
  
5. Maven的包
   * 按照约定为所有的包编号，方便检索
   * groupId/artifactId/version
      * 拓展：语义化版本
      * 版本格式：主版本号.次版本号.修订号
      * 主版本号：当你做不了API兼容的修改
      * 次版本号：当你做了向下兼容的功能性新增
      * 修订号：当你做了向下兼容的修正
   * SNAPSHOT 快照版本
     * 当代码处于开发中需要频繁变更， SNAPSHOT ，允许不停的更新
     * 上线时候会变成正式版本

6. 传递性依赖的自动管理
   * 原则：绝对不允许最终的classpath出现同名不同版本的jar包
  
7. 依赖冲突的解决：最近的胜出
    * A-B-C2
    * D-C1胜出
    * 可能会产生错误 

    * 解决冲突的方法
        * 在项目pom.xml文件中，强行选择依赖版本高的类
        * 在pom.xml中，直接把依赖版本低的类去除掉
        * 使用Maven helper插件解决

    * 出现以下报错，说明有包冲突
      * NoSunchMethodError
      *  AbstractMethodError
      *  NoClassDefFoundError
      *  ClassNotFoundException
      *  LinkageError

    * 如何查询依赖包的关系
      * 命令行：mvn dependency:tree(展示的是冲突解决掉的关系)
      * 可以把关系树定向到文本中，使用文本编辑器查看

    * 如何查找两个版本的区别
      * repo1.maven.org/maven2里找类的不同版本，找到pom文件，对比源代码

    * 当两个版本一样近时，谁在前面，谁赢

8. 依赖的scope（作用域）
    * compile：在 main 和 test 中都可以使用这个依赖
    * test：只能在test中使用这个依赖
    * provide：只有在编译时可以使用，运行时不可以